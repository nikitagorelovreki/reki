# Reki Control Panel - Cursor AI Rules

You are an AI assistant helping with the Reki Control Panel project, a comprehensive medical device management and patient assessment system built with TypeScript and following Clean Architecture principles.

## Project Structure & Architecture

This is a TypeScript monorepo with the following packages:
- `packages/app-control-panel/` - React + Webpack + Ant Design + TypeScript frontend
- `packages/app-core-server/` - Main NestJS backend application server
- `packages/app-auth-server/` - Authentication server
- `packages/app-telegram-bot/` - Telegram bot integration
- `packages/core-domain/` - Core domain entities, value objects, and ports (DDD)
- `packages/core-service/` - Core application business logic and services
- `packages/core-persistence/` - Core data access layer and repository implementations
- `packages/auth-domain/` - Authentication domain entities and ports
- `packages/auth-service/` - Authentication business logic
- `packages/auth-persistence/` - Authentication data access layer
- `packages/api/` - API controllers and DTOs
- `packages/persistence-commons/` - Shared persistence utilities

## Technology Stack

### Frontend
- React 18 with TypeScript
- Webpack for bundling and development
- Ant Design (antd) for UI components
- React Router for routing
- Axios for HTTP requests
- Day.js for date handling
- Chart.js for data visualization

### Backend
- NestJS framework
- TypeScript with decorators
- Class-validator and class-transformer for validation
- Swagger/OpenAPI for documentation
- PostgreSQL with Knex.js query builder
- Clean Architecture with DDD patterns

### Build & Development
- Turbo for monorepo management
- ESLint for linting
- Prettier for code formatting
- Jest for testing

## Clean Architecture Layer Rules

### Dependency Flow
```
API Layer
    ↓ (injects)
Service Layer  
    ↓ (injects)
Persistence Layer
    ↓ (implements)
Domain Layer (ports & entities)
```

### API Layer Restrictions
- ❌ NEVER import from domain layers directly
- ❌ NEVER import from persistence layers directly
- ✅ ONLY import from service layers
- ✅ Define DTOs locally or import from shared types
- ✅ Use dependency injection for services

### Service Layer Restrictions
- ❌ NEVER import from API layer
- ✅ MUST import from persistence layer (repositories)
- ✅ MUST import from domain layer (entities, ports)
- ✅ Export service models and interfaces
- ✅ Handle business logic and orchestrate domain + persistence

### Domain Layer Restrictions
- ❌ NEVER import from any other layer
- ✅ ONLY define entities, value objects, ports
- ✅ NO external dependencies except utilities
- ✅ Define repository interfaces (ports)

### Persistence Layer Restrictions
- ❌ NEVER import from API layer
- ✅ ONLY import from domain layer
- ✅ Implement repository ports from domain
- ✅ Handle data mapping between domain and database

## Model Layer Rules

### API Layer Models (DTOs)
```typescript
// ✅ CORRECT - API DTOs
export class CreateDeviceDto {
  @IsString() serial!: string;
  @IsString() model!: string;
  @IsEnum(DeviceStatus) status?: DeviceStatus;
}

// ✅ CORRECT - API Response DTOs  
export class DeviceResponseDto {
  id: string;
  serial: string;
  model: string;
  status: DeviceStatus;
  createdAt: string; // ISO string for API
  updatedAt: string;
}

// ✅ CORRECT - Local enums for API
export enum DeviceStatus {
  REGISTERED = 'registered',
  ACTIVE = 'active',
  MAINTENANCE = 'maintenance',
}
```

### Service Layer Models
```typescript
// ✅ CORRECT - Service models
export interface ServiceDevice {
  id: string;
  serial: string;
  model: string;
  status: string;
  createdAt: string; // ISO string
  updatedAt: string;
}

// ✅ CORRECT - Service DTOs
export interface ServiceCreateDeviceDto {
  serial: string;
  model: string;
  status?: string;
}
```

### Domain Layer Models
```typescript
// ✅ CORRECT - Domain entities
export class Device {
  id: string;
  serial: string;
  model: string;
  status: DeviceStatus;
  createdAt: Date; // Date object
  updatedAt: Date;
}

// ✅ CORRECT - Domain ports
export interface DeviceRepositoryPort {
  create(device: Device): Promise<Device>;
  findById(id: string): Promise<Device | null>;
  findAll(page: number, limit: number): Promise<Device[]>;
}
```

### ❌ WRONG - Never do this:
```typescript
// ❌ DON'T import domain models in API
import { Device } from '@reki/domain';

// ❌ DON'T reuse domain models as DTOs
export class CreateDeviceDto extends Device {}

// ❌ DON'T import API DTOs in service
import { CreateDeviceDto } from '@reki/api';
```

## Code Style Guidelines

### General TypeScript Rules

1. **Interfaces and Types**
   - Use `interface` for object shapes that might be extended
   - Use `type` for unions, primitives, and computed types
   - Always export public interfaces/types
   - Use PascalCase for interfaces and types
   - Use descriptive names (e.g., `CreateDeviceDto` not `DeviceCreate`)

2. **Naming Conventions**
   - Variables/functions: camelCase
   - Classes/Interfaces/Types: PascalCase
   - Constants: UPPER_SNAKE_CASE
   - Files: kebab-case.extension or PascalCase.extension for components
   - Directories: kebab-case

3. **Import Organization**
   ```typescript
   // 1. External libraries
   import React from 'react';
   import { Injectable } from '@nestjs/common';

   // 2. Internal packages (from other workspace packages)
   import { Device, DeviceRepositoryPort } from '@reki/core-domain';
   import { DeviceService } from '@reki/core-service';

   // 3. Relative imports
   import { DeviceCard } from './DeviceCard';
   import type { DeviceProps } from '../types';
   ```

### Frontend (React) Guidelines

1. **Component Structure**
   ```typescript
   import React, { useState, useEffect } from 'react';
   import type { ComponentProps } from './types';

   interface ComponentNameProps {
     // Props definition
   }

   const ComponentName: React.FC<ComponentNameProps> = ({ prop1, prop2 }) => {
     // State hooks first
     const [state, setState] = useState<Type>(initialValue);

     // Effect hooks
     useEffect(() => {
       // Effect logic
     }, [dependencies]);

     // Event handlers
     const handleEvent = () => {
       // Handler logic
     };

     // Render
     return (
       <div>
         {/* Component JSX */}
       </div>
     );
   };

   export default ComponentName;
   ```

2. **State Management**
   - Use `useState` for local component state
   - Always provide type annotations for state
   - Use descriptive state names
   - Group related state together

3. **Event Handlers**
   - Prefix with `handle` (e.g., `handleSubmit`, `handleChange`)
   - Use arrow functions for inline handlers
   - Extract complex logic into separate functions

4. **Ant Design Patterns**
   - Import specific components: `import { Button, Card } from 'antd';`
   - Use Ant Design's TypeScript types when available
   - Follow Ant Design naming conventions for props

### Backend (NestJS) Guidelines

1. **Module Structure**
   ```typescript
   @Module({
     imports: [
       // External modules first
       ConfigModule,
       // Internal modules
       CoreServiceModule,
       CorePersistenceModule,
     ],
     controllers: [ControllerName],
     providers: [ServiceName],
     exports: [ServiceName],
   })
   export class ModuleName {}
   ```

2. **Service Structure**
   ```typescript
   @Injectable()
   export class ServiceName {
     constructor(
       private readonly repository: RepositoryPort,
       private readonly mapper: Mapper,
     ) {}

     async methodName(param: ServiceDto): Promise<ServiceModel> {
       // 1. Map service DTO to domain entity
       const domainEntity = this.mapper.mapServiceToDomain(param);
       
       // 2. Use persistence layer
       const result = await this.repository.create(domainEntity);
       
       // 3. Map domain entity back to service model
       return this.mapper.mapDomainToService(result);
     }
   }
   ```

3. **Controller Structure**
   ```typescript
   @Controller('resource')
   @ApiTags('resource')
   export class ResourceController {
     constructor(private readonly service: ResourceService) {}

     @Get()
     @ApiOperation({ summary: 'Get all resources' })
     @ApiResponse({ status: 200, type: [ResourceDto] })
     async getAll(@Query() query: GetAllDto): Promise<ResourceDto[]> {
       return this.service.getAll(query);
     }
   }
   ```

### Domain Layer Guidelines

1. **Entities and Value Objects**
   ```typescript
   export class EntityName {
     // Properties with explicit types
     id: string;
     name: string;
     status: EntityStatus;
     createdAt: Date;
     updatedAt: Date;

     constructor(data: Partial<EntityName>) {
       // Initialize with defaults
       this.id = data.id || uuidv4();
       this.createdAt = data.createdAt || new Date();
       this.updatedAt = data.updatedAt || new Date();
       // ... other properties
     }

     // Business methods
     updateStatus(status: EntityStatus): void {
       this.status = status;
       this.updatedAt = new Date();
     }
   }
   ```

2. **Repository Ports**
   ```typescript
   export interface EntityRepositoryPort {
     findById(id: string): Promise<Entity | null>;
     findAll(page: number, limit: number): Promise<Entity[]>;
     create(entity: Entity): Promise<Entity>;
     update(id: string, entity: Partial<Entity>): Promise<Entity | null>;
     delete(id: string): Promise<void>;
   }
   ```

### Error Handling

1. **Frontend Error Handling**
   ```typescript
   try {
     const result = await apiCall();
     // Handle success
   } catch (error) {
     console.error('Error description:', error);
     message.error('User-friendly error message');
   }
   ```

2. **Backend Error Handling**
   ```typescript
   async methodName(): Promise<Type> {
     try {
       return await this.operation();
     } catch (error) {
       throw new NotFoundException('Resource not found');
     }
   }
   ```

### File Organization

## Complete Project Structure

```
reki/
├── packages/
│   ├── core-domain/              # Core business domain (DDD)
│   │   ├── src/
│   │   │   ├── models/            # Domain entities
│   │   │   │   ├── client.model.ts
│   │   │   │   ├── device.model.ts
│   │   │   │   ├── examination.model.ts
│   │   │   │   ├── form-entry.model.ts
│   │   │   │   └── form.model.ts
│   │   │   ├── types/             # Domain types and enums
│   │   │   │   └── pagination.ts
│   │   │   ├── core-domain.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── core-service/             # Core business logic services
│   │   ├── src/
│   │   │   ├── services/          # Business logic services
│   │   │   │   ├── client.service.ts
│   │   │   │   ├── device.service.ts
│   │   │   │   ├── form.service.ts
│   │   │   │   └── examination.service.ts
│   │   │   ├── mappers/           # Data mappers
│   │   │   │   ├── client.mapper.ts
│   │   │   │   ├── device.mapper.ts
│   │   │   │   └── form.mapper.ts
│   │   │   ├── models/            # Service models
│   │   │   │   ├── service-client.model.ts
│   │   │   │   ├── service-device.model.ts
│   │   │   │   └── service-form.model.ts
│   │   │   ├── core-service.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── core-persistence/         # Core data access layer
│   │   ├── src/
│   │   │   ├── repositories/      # Repository implementations
│   │   │   │   ├── client.repository.ts
│   │   │   │   ├── device.repository.ts
│   │   │   │   ├── form.repository.ts
│   │   │   │   └── examination.repository.ts
│   │   │   ├── database/          # Database configuration
│   │   │   │   ├── connection.ts
│   │   │   │   └── migrations/
│   │   │   ├── utils/             # Database utilities
│   │   │   ├── ports/             # Repository interfaces
│   │   │   ├── core-persistence.module.ts
│   │   │   └── index.ts
│   │   ├── database/
│   │   │   └── migrations/        # Database migrations
│   │   └── package.json
│   │
│   ├── auth-domain/               # Authentication domain
│   │   ├── src/
│   │   │   ├── models/            # Auth entities
│   │   │   │   ├── user.model.ts
│   │   │   │   └── role.model.ts
│   │   │   ├── types/             # Auth types
│   │   │   ├── auth-domain.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── auth-service/              # Authentication business logic
│   │   ├── src/
│   │   │   ├── services/          # Auth services
│   │   │   │   ├── auth.service.ts
│   │   │   │   └── user.service.ts
│   │   │   ├── mappers/           # Auth mappers
│   │   │   ├── models/            # Auth service models
│   │   │   ├── auth-service.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── auth-persistence/         # Authentication data access
│   │   ├── src/
│   │   │   ├── repositories/      # Auth repository implementations
│   │   │   │   ├── user.repository.ts
│   │   │   │   └── role.repository.ts
│   │   │   ├── auth-persistence.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── persistence-commons/       # Shared persistence utilities
│   │   ├── src/
│   │   │   ├── utils/             # Common database utilities
│   │   │   │   ├── database.utils.ts
│   │   │   │   └── query.utils.ts
│   │   │   ├── types/             # Common persistence types
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── api/                       # API layer (controllers & DTOs)
│   │   ├── src/
│   │   │   ├── clients/            # Client API endpoints
│   │   │   │   ├── client.controller.ts
│   │   │   │   └── client.dto.ts
│   │   │   ├── devices/            # Device API endpoints
│   │   │   │   ├── device.controller.ts
│   │   │   │   └── device.dto.ts
│   │   │   ├── forms/              # Form API endpoints
│   │   │   │   ├── form.controller.ts
│   │   │   │   └── form.dto.ts
│   │   │   ├── common/             # Common API utilities
│   │   │   │   ├── pagination.dto.ts
│   │   │   │   └── response.dto.ts
│   │   │   ├── dto/                # Shared DTOs
│   │   │   ├── mappers/            # API mappers
│   │   │   ├── api.module.ts
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── app-core-server/           # Main NestJS application server
│   │   ├── src/
│   │   │   ├── app.module.ts       # Main application module
│   │   │   ├── main.ts             # Application entry point
│   │   │   ├── providers.ts        # Global providers
│   │   │   ├── config/             # Application configuration
│   │   │   └── middleware/         # Global middleware
│   │   ├── __tests__/              # Application tests
│   │   └── package.json
│   │
│   ├── app-auth-server/           # Authentication server
│   │   ├── src/
│   │   │   ├── app-auth-server.module.ts
│   │   │   ├── main.ts
│   │   │   └── config/
│   │   └── package.json
│   │
│   ├── app-control-panel/          # React frontend application
│   │   ├── src/
│   │   │   ├── components/         # Reusable components
│   │   │   │   ├── Layout/         # Layout components
│   │   │   │   │   ├── MainLayout.tsx
│   │   │   │   │   └── Sidebar.tsx
│   │   │   │   ├── Charts/         # Chart components
│   │   │   │   │   ├── RadarChart.tsx
│   │   │   │   │   └── LineChart.tsx
│   │   │   │   └── Forms/          # Form components
│   │   │   │       ├── FormBuilder.tsx
│   │   │   │       └── FormRenderer.tsx
│   │   │   ├── pages/              # Page components
│   │   │   │   ├── Dashboard/      # Dashboard page
│   │   │   │   │   ├── DashboardPage.tsx
│   │   │   │   │   └── DashboardStats.tsx
│   │   │   │   ├── Devices/        # Device management
│   │   │   │   │   ├── DevicesPage.tsx
│   │   │   │   │   └── DeviceCard.tsx
│   │   │   │   ├── Forms/          # Form management
│   │   │   │   │   ├── FormsPage.tsx
│   │   │   │   │   └── FormBuilder.tsx
│   │   │   │   └── Clients/        # Client management
│   │   │   │       ├── ClientsPage.tsx
│   │   │   │       └── ClientCard.tsx
│   │   │   ├── types/              # TypeScript type definitions
│   │   │   │   ├── api.types.ts
│   │   │   │   ├── components.types.ts
│   │   │   │   └── index.ts
│   │   │   ├── api/                # API client functions
│   │   │   │   ├── clients.api.ts
│   │   │   │   ├── devices.api.ts
│   │   │   │   └── forms.api.ts
│   │   │   ├── assets/             # Static assets
│   │   │   │   ├── images/
│   │   │   │   └── icons/
│   │   │   ├── utils/              # Utility functions
│   │   │   │   ├── date.utils.ts
│   │   │   │   └── validation.utils.ts
│   │   │   ├── App.tsx
│   │   │   ├── main.tsx
│   │   │   └── index.css
│   │   ├── webpack.config.js       # Webpack configuration
│   │   ├── index.html
│   │   └── package.json
│   │
│   └── app-telegram-bot/           # Telegram bot integration
│       ├── src/
│       │   ├── services/           # Bot services
│       │   │   ├── bot.service.ts
│       │   │   └── api.service.ts
│       │   ├── handlers/           # Command handlers
│       │   │   ├── device.handler.ts
│       │   │   ├── client.handler.ts
│       │   │   └── support.handler.ts
│       │   ├── types/              # Bot types
│       │   │   ├── bot.types.ts
│       │   │   └── commands.types.ts
│       │   ├── utils/              # Bot utilities
│       │   └── main.ts
│       └── package.json
│
├── config/                         # Shared configuration
│   ├── eslint.config.js            # ESLint configuration
│   ├── jest.config.js              # Jest configuration
│   ├── jest.setup.js               # Jest setup
│   └── eslint-rules/               # Custom ESLint rules
│       └── no-domain-imports.js    # Architecture validation rule
│
├── docs/                           # Documentation
│   ├── ai-agents/                  # AI agent documentation
│   ├── api/                        # API documentation
│   ├── architecture/               # Architecture documentation
│   ├── deployment/                 # Deployment guides
│   ├── development/                # Development guides
│   ├── integrations/               # Integration guides
│   ├── testing/                    # Testing documentation
│   └── user-guides/                # User guides
│
├── scripts/                        # Build and deployment scripts
│   └── create-package.js           # Package creation utility
│
├── docker-compose.yml              # Docker services
├── package.json                    # Root package.json
├── turbo.json                      # Turbo configuration
└── .cursorrules                    # Cursor AI rules
```

## Package Dependencies & Architecture

### Dependency Flow (Clean Architecture)
```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
├─────────────────────────────────────────────────────────────┤
│  app-control-panel  │  app-core-server  │  app-telegram-bot │
├─────────────────────────────────────────────────────────────┤
│                   API Layer                                │
├─────────────────────────────────────────────────────────────┤
│                        api/                                 │
├─────────────────────────────────────────────────────────────┤
│                 Service Layer                               │
├─────────────────────────────────────────────────────────────┤
│              core-service  │  auth-service                 │
├─────────────────────────────────────────────────────────────┤
│               Persistence Layer                             │
├─────────────────────────────────────────────────────────────┤
│         core-persistence  │  auth-persistence               │
├─────────────────────────────────────────────────────────────┤
│                 Domain Layer                                │
├─────────────────────────────────────────────────────────────┤
│              core-domain  │  auth-domain                   │
├─────────────────────────────────────────────────────────────┤
│              Infrastructure Layer                            │
├─────────────────────────────────────────────────────────────┤
│  persistence-commons  │  Database  │  External Services    │
└─────────────────────────────────────────────────────────────┘
```

### Package Dependencies Matrix

| Package | Dependencies | Purpose |
|---------|-------------|---------|
| `core-domain` | `uuid` | Core business entities and ports |
| `auth-domain` | `uuid` | Authentication entities and ports |
| `persistence-commons` | `@nestjs/common`, `knex`, `pg` | Shared database utilities |
| `core-persistence` | `@reki/core-domain`, `@reki/persistence-commons`, `knex`, `pg` | Core data access implementation |
| `auth-persistence` | `@reki/auth-domain`, `@reki/persistence-commons` | Auth data access implementation |
| `core-service` | `@reki/core-domain`, `@reki/core-persistence`, `@nestjs/common` | Core business logic |
| `auth-service` | `@reki/auth-domain`, `@reki/auth-persistence` | Auth business logic |
| `api` | `@reki/core-service`, `@reki/auth-service`, `class-validator` | API controllers and DTOs |
| `app-core-server` | `@reki/api`, `@reki/core-persistence`, `@reki/core-service` | Main NestJS application |
| `app-auth-server` | `@reki/auth-service`, `@reki/auth-persistence` | Auth NestJS application |
| `app-control-panel` | `@reki/api`, `react`, `antd`, `webpack` | React frontend |
| `app-telegram-bot` | `@reki/api` | Telegram bot |

### Layer Isolation Rules

1. **Domain Layer** (`core-domain`, `auth-domain`)
   - ❌ NO external dependencies except utilities
   - ✅ ONLY define entities, value objects, ports
   - ✅ Define repository interfaces (ports)

2. **Persistence Layer** (`core-persistence`, `auth-persistence`)
   - ❌ NEVER import from API layer
   - ✅ ONLY import from domain layer
   - ✅ Implement repository ports from domain
   - ✅ Use `persistence-commons` for shared utilities

3. **Service Layer** (`core-service`, `auth-service`)
   - ❌ NEVER import from API layer
   - ✅ MUST import from persistence layer (repositories)
   - ✅ MUST import from domain layer (entities, ports)
   - ✅ Export service models and interfaces

4. **API Layer** (`api`)
   - ❌ NEVER import from domain layers directly
   - ❌ NEVER import from persistence layers directly
   - ✅ ONLY import from service layers
   - ✅ Define DTOs locally or import from shared types

5. **Application Layer** (`app-*`)
   - ✅ Import from API layer for controllers
   - ✅ Import from service layer for direct service usage
   - ✅ Configure dependency injection

### Module Organization

#### Domain Modules
- **core-domain**: Core business entities (Client, Device, Form, Examination)
- **auth-domain**: Authentication entities (User, Role)

#### Service Modules
- **core-service**: Business logic for core domain
- **auth-service**: Business logic for authentication

#### Persistence Modules
- **core-persistence**: Data access for core domain
- **auth-persistence**: Data access for authentication
- **persistence-commons**: Shared database utilities

#### API Modules
- **api**: HTTP controllers and DTOs for all domains

#### Application Modules
- **app-core-server**: Main NestJS application
- **app-auth-server**: Authentication server
- **app-control-panel**: React frontend
- **app-telegram-bot**: Telegram bot

## Language Support

- Use English for code, comments, and documentation
- UI text should be in Russian
- API documentation should be in English
- Variable names should be in English for consistency

## Database and API Conventions

1. **Database Fields**
   - Use snake_case for database column names
   - Use camelCase in TypeScript code
   - Provide field mappings in models

2. **API Design**
   - RESTful endpoints with proper HTTP methods
   - Use `/api` prefix
   - Swagger documentation for all endpoints
   - Consistent error response format

## Testing Guidelines

1. Write unit tests for business logic
2. Integration tests for API endpoints
3. Component tests for React components
4. Use descriptive test names in English

## Common Patterns to Follow

1. **Repository Pattern**: Use for data access
2. **Service Layer**: Business logic in services
3. **DTO Pattern**: For API data transfer
4. **Entity Pattern**: Rich domain models
5. **Factory Pattern**: For complex object creation
6. **Mapper Pattern**: For converting between layers

## Code Quality Checklist

- [ ] All functions have proper TypeScript types
- [ ] Error handling is implemented
- [ ] Comments are clear and in English
- [ ] Tests are written for new functionality
- [ ] Swagger documentation is updated for API changes
- [ ] Database migrations are created for schema changes
- [ ] Performance implications are considered
- [ ] Layer isolation rules are followed
- [ ] No circular dependencies between layers

When writing code, always consider the clean architecture principles and maintain consistency with the existing codebase patterns.