# Reki Control Panel - Cursor AI Rules

You are an AI assistant helping with the Reki Control Panel project, a comprehensive medical device management and patient assessment system built with TypeScript and following Clean Architecture principles.

## Project Structure & Architecture

This is a TypeScript monorepo with the following packages:
- `packages/app-control-panel/` - React + Vite + Ant Design + TypeScript frontend
- `packages/app-core-server/` - Main NestJS backend application server
- `packages/app-auth-server/` - Authentication server
- `packages/app-telegram-bot/` - Telegram bot integration
- `packages/core-domain/` - Core domain entities, value objects, and ports (DDD)
- `packages/core-service/` - Core application business logic and services
- `packages/core-persistence/` - Core data access layer and repository implementations
- `packages/auth-domain/` - Authentication domain entities and ports
- `packages/auth-service/` - Authentication business logic
- `packages/auth-persistence/` - Authentication data access layer
- `packages/api/` - API controllers and DTOs
- `packages/persistence-commons/` - Shared persistence utilities

## Technology Stack

### Frontend
- React 18 with TypeScript
- Vite for bundling and development
- Ant Design (antd) for UI components
- React Router for routing
- Axios for HTTP requests
- Day.js for date handling

### Backend
- NestJS framework
- TypeScript with decorators
- Class-validator and class-transformer for validation
- Swagger/OpenAPI for documentation
- PostgreSQL with Knex.js query builder
- Clean Architecture with DDD patterns

### Build & Development
- Turbo for monorepo management
- ESLint for linting
- Prettier for code formatting
- Jest for testing

## Clean Architecture Layer Rules

### Dependency Flow
```
API Layer
    ↓ (injects)
Service Layer  
    ↓ (injects)
Persistence Layer
    ↓ (implements)
Domain Layer (ports & entities)
```

### API Layer Restrictions
- ❌ NEVER import from domain layers directly
- ❌ NEVER import from persistence layers directly
- ✅ ONLY import from service layers
- ✅ Define DTOs locally or import from shared types
- ✅ Use dependency injection for services

### Service Layer Restrictions
- ❌ NEVER import from API layer
- ✅ MUST import from persistence layer (repositories)
- ✅ MUST import from domain layer (entities, ports)
- ✅ Export service models and interfaces
- ✅ Handle business logic and orchestrate domain + persistence

### Domain Layer Restrictions
- ❌ NEVER import from any other layer
- ✅ ONLY define entities, value objects, ports
- ✅ NO external dependencies except utilities
- ✅ Define repository interfaces (ports)

### Persistence Layer Restrictions
- ❌ NEVER import from API layer
- ✅ ONLY import from domain layer
- ✅ Implement repository ports from domain
- ✅ Handle data mapping between domain and database

## Model Layer Rules

### API Layer Models (DTOs)
```typescript
// ✅ CORRECT - API DTOs
export class CreateDeviceDto {
  @IsString() serial!: string;
  @IsString() model!: string;
  @IsEnum(DeviceStatus) status?: DeviceStatus;
}

// ✅ CORRECT - API Response DTOs  
export class DeviceResponseDto {
  id: string;
  serial: string;
  model: string;
  status: DeviceStatus;
  createdAt: string; // ISO string for API
  updatedAt: string;
}

// ✅ CORRECT - Local enums for API
export enum DeviceStatus {
  REGISTERED = 'registered',
  ACTIVE = 'active',
  MAINTENANCE = 'maintenance',
}
```

### Service Layer Models
```typescript
// ✅ CORRECT - Service models
export interface ServiceDevice {
  id: string;
  serial: string;
  model: string;
  status: string;
  createdAt: string; // ISO string
  updatedAt: string;
}

// ✅ CORRECT - Service DTOs
export interface ServiceCreateDeviceDto {
  serial: string;
  model: string;
  status?: string;
}
```

### Domain Layer Models
```typescript
// ✅ CORRECT - Domain entities
export class Device {
  id: string;
  serial: string;
  model: string;
  status: DeviceStatus;
  createdAt: Date; // Date object
  updatedAt: Date;
}

// ✅ CORRECT - Domain ports
export interface DeviceRepositoryPort {
  create(device: Device): Promise<Device>;
  findById(id: string): Promise<Device | null>;
  findAll(page: number, limit: number): Promise<Device[]>;
}
```

### ❌ WRONG - Never do this:
```typescript
// ❌ DON'T import domain models in API
import { Device } from '@reki/domain';

// ❌ DON'T reuse domain models as DTOs
export class CreateDeviceDto extends Device {}

// ❌ DON'T import API DTOs in service
import { CreateDeviceDto } from '@reki/api';
```

## Code Style Guidelines

### General TypeScript Rules

1. **Interfaces and Types**
   - Use `interface` for object shapes that might be extended
   - Use `type` for unions, primitives, and computed types
   - Always export public interfaces/types
   - Use PascalCase for interfaces and types
   - Use descriptive names (e.g., `CreateDeviceDto` not `DeviceCreate`)

2. **Naming Conventions**
   - Variables/functions: camelCase
   - Classes/Interfaces/Types: PascalCase
   - Constants: UPPER_SNAKE_CASE
   - Files: kebab-case.extension or PascalCase.extension for components
   - Directories: kebab-case

3. **Import Organization**
   ```typescript
   // 1. External libraries
   import React from 'react';
   import { Injectable } from '@nestjs/common';

   // 2. Internal packages (from other workspace packages)
   import { Device, DeviceRepositoryPort } from '@reki/core-domain';
   import { DeviceService } from '@reki/core-service';

   // 3. Relative imports
   import { DeviceCard } from './DeviceCard';
   import type { DeviceProps } from '../types';
   ```

### Frontend (React) Guidelines

1. **Component Structure**
   ```typescript
   import React, { useState, useEffect } from 'react';
   import type { ComponentProps } from './types';

   interface ComponentNameProps {
     // Props definition
   }

   const ComponentName: React.FC<ComponentNameProps> = ({ prop1, prop2 }) => {
     // State hooks first
     const [state, setState] = useState<Type>(initialValue);

     // Effect hooks
     useEffect(() => {
       // Effect logic
     }, [dependencies]);

     // Event handlers
     const handleEvent = () => {
       // Handler logic
     };

     // Render
     return (
       <div>
         {/* Component JSX */}
       </div>
     );
   };

   export default ComponentName;
   ```

2. **State Management**
   - Use `useState` for local component state
   - Always provide type annotations for state
   - Use descriptive state names
   - Group related state together

3. **Event Handlers**
   - Prefix with `handle` (e.g., `handleSubmit`, `handleChange`)
   - Use arrow functions for inline handlers
   - Extract complex logic into separate functions

4. **Ant Design Patterns**
   - Import specific components: `import { Button, Card } from 'antd';`
   - Use Ant Design's TypeScript types when available
   - Follow Ant Design naming conventions for props

### Backend (NestJS) Guidelines

1. **Module Structure**
   ```typescript
   @Module({
     imports: [
       // External modules first
       ConfigModule,
       // Internal modules
       CoreServiceModule,
       CorePersistenceModule,
     ],
     controllers: [ControllerName],
     providers: [ServiceName],
     exports: [ServiceName],
   })
   export class ModuleName {}
   ```

2. **Service Structure**
   ```typescript
   @Injectable()
   export class ServiceName {
     constructor(
       private readonly repository: RepositoryPort,
       private readonly mapper: Mapper,
     ) {}

     async methodName(param: ServiceDto): Promise<ServiceModel> {
       // 1. Map service DTO to domain entity
       const domainEntity = this.mapper.mapServiceToDomain(param);
       
       // 2. Use persistence layer
       const result = await this.repository.create(domainEntity);
       
       // 3. Map domain entity back to service model
       return this.mapper.mapDomainToService(result);
     }
   }
   ```

3. **Controller Structure**
   ```typescript
   @Controller('resource')
   @ApiTags('resource')
   export class ResourceController {
     constructor(private readonly service: ResourceService) {}

     @Get()
     @ApiOperation({ summary: 'Get all resources' })
     @ApiResponse({ status: 200, type: [ResourceDto] })
     async getAll(@Query() query: GetAllDto): Promise<ResourceDto[]> {
       return this.service.getAll(query);
     }
   }
   ```

### Domain Layer Guidelines

1. **Entities and Value Objects**
   ```typescript
   export class EntityName {
     // Properties with explicit types
     id: string;
     name: string;
     status: EntityStatus;
     createdAt: Date;
     updatedAt: Date;

     constructor(data: Partial<EntityName>) {
       // Initialize with defaults
       this.id = data.id || uuidv4();
       this.createdAt = data.createdAt || new Date();
       this.updatedAt = data.updatedAt || new Date();
       // ... other properties
     }

     // Business methods
     updateStatus(status: EntityStatus): void {
       this.status = status;
       this.updatedAt = new Date();
     }
   }
   ```

2. **Repository Ports**
   ```typescript
   export interface EntityRepositoryPort {
     findById(id: string): Promise<Entity | null>;
     findAll(page: number, limit: number): Promise<Entity[]>;
     create(entity: Entity): Promise<Entity>;
     update(id: string, entity: Partial<Entity>): Promise<Entity | null>;
     delete(id: string): Promise<void>;
   }
   ```

### Error Handling

1. **Frontend Error Handling**
   ```typescript
   try {
     const result = await apiCall();
     // Handle success
   } catch (error) {
     console.error('Error description:', error);
     message.error('User-friendly error message');
   }
   ```

2. **Backend Error Handling**
   ```typescript
   async methodName(): Promise<Type> {
     try {
       return await this.operation();
     } catch (error) {
       throw new NotFoundException('Resource not found');
     }
   }
   ```

### File Organization

1. **Frontend Structure**
   ```
   src/
   ├── components/          # Reusable components
   │   ├── Layout/
   │   └── Common/
   ├── pages/              # Page components
   ├── types/              # TypeScript type definitions
   ├── api/                # API client functions
   ├── hooks/              # Custom React hooks
   └── utils/              # Utility functions
   ```

2. **Backend Structure**
   ```
   src/
   ├── controllers/        # NestJS controllers
   ├── services/          # Application services
   ├── modules/           # NestJS modules
   ├── dtos/              # Data Transfer Objects
   └── config/            # Configuration files
   ```

## Russian Language Support

- Use Russian comments and documentation where appropriate
- UI text should be in Russian
- API documentation can be in English
- Variable names should be in English for consistency

## Database and API Conventions

1. **Database Fields**
   - Use snake_case for database column names
   - Use camelCase in TypeScript code
   - Provide field mappings in models

2. **API Design**
   - RESTful endpoints with proper HTTP methods
   - Use `/api` prefix
   - Swagger documentation for all endpoints
   - Consistent error response format

## Performance Considerations

1. **Frontend**
   - Use React.memo for expensive components
   - Implement proper dependency arrays in useEffect
   - Lazy load components where appropriate

2. **Backend**
   - Use proper database indexing
   - Implement pagination for list endpoints
   - Use proper caching strategies

## Testing Guidelines

1. Write unit tests for business logic
2. Integration tests for API endpoints
3. Component tests for React components
4. Use descriptive test names in Russian or English

## Common Patterns to Follow

1. **Repository Pattern**: Use for data access
2. **Service Layer**: Business logic in services
3. **DTO Pattern**: For API data transfer
4. **Entity Pattern**: Rich domain models
5. **Factory Pattern**: For complex object creation
6. **Mapper Pattern**: For converting between layers

## Code Quality Checklist

- [ ] All functions have proper TypeScript types
- [ ] Error handling is implemented
- [ ] Comments are clear and in appropriate language
- [ ] Tests are written for new functionality
- [ ] Swagger documentation is updated for API changes
- [ ] Database migrations are created for schema changes
- [ ] Performance implications are considered
- [ ] Layer isolation rules are followed
- [ ] No circular dependencies between layers

When writing code, always consider the clean architecture principles and maintain consistency with the existing codebase patterns.